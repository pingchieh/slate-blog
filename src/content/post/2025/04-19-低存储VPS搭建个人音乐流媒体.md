---
title: 低存储VPS搭建个人音乐流媒体
description: 利用Navidrome, Cloudflare Workers和云存储，在低存储VPS上搭建个人音乐流媒体服务。
tags: [Navidrome, Cloudflare, 音乐流媒体, VPS]
pubDate: 2025-04-19
draft: false
---


你是否拥有大量的本地音乐收藏，希望随时随地访问，但又受限于 VPS 或服务器的存储空间？本文将介绍一种巧妙的解决方案，利用 Navidrome、Cloudflare Workers 和你的云存储（如 R2、S3、或 Alist 挂载的网盘），在低存储的 VPS 上搭建功能完善的个人音乐流媒体服务。

**核心思路：**

利用本地计算机生成 Navidrome 的音乐元数据数据库，然后将此数据库部署到 VPS 上的 Navidrome 实例（该实例不扫描实际文件）。接着，通过 Cloudflare Workers 拦截 Navidrome 的音乐文件请求，查询 Cloudflare D1 数据库（预先存储了文件 ID 和云端路径的映射关系），最终将请求重定向到实际存储音乐文件的云端地址。

## 前提条件

在开始之前，请确保你具备以下条件：

1. **音乐文件：** 本地计算机存有一份完整的音乐库，同时在云存储（如 Cloudflare R2, AWS S3, Google Cloud Storage, 或通过 Alist 暴露的网盘等）也有一份完全一致的副本。
2. **本地环境：** 一台可以运行 Navidrome 并访问完整音乐库的本地计算机，用于初次扫描。
3. **服务器环境：** 一台 VPS 或其他可以运行 Navidrome 的容器服务（存储空间可以很小）。
4. **Cloudflare 账户：** 用于 DNS 解析、Workers 和 D1 数据库服务。
5. **云存储访问：** 确保你的云存储可以被公开或半公开访问（例如，通过签名 URL 或公开存储桶），以便 Worker 重定向后能够访问。
6. **工具：**
    * Navidrome 程序
    * SQLite 编辑工具（如 DB Browser for SQLite, DBeaver, 或文中提到的 `sqlitestudio`）
    * Cloudflare `wrangler` CLI 工具 (通过 `npm install -g wrangler` 安装)

### 第一步：本地扫描与数据库准备

此步骤的目的是利用本地强大的计算资源和完整的音乐文件，生成 Navidrome 所需的核心数据库文件。

1. **本地运行 Navidrome：** 在你的本地计算机上配置并运行 Navidrome，确保 `MusicFolder` 指向你完整的本地音乐库路径。让 Navidrome 完成一次彻底的扫描。
2. **获取数据库文件：** 扫描完成后，在 Navidrome 的数据目录（通常由 `DataFolder` 配置项指定）中找到 `navidrome.db` 文件。这个文件包含了所有音乐的元数据、播放列表信息以及文件路径（相对于本地扫描目录）。
3. **上传数据库：** 将这个 `navidrome.db` 文件上传到你的 VPS 上，放置在计划运行 Navidrome (VPS 版) 的数据目录中。

### 第二步：在 VPS 部署 Navidrome (仅元数据模式)

现在，我们在存储有限的 VPS 上运行 Navidrome，但配置它不主动扫描文件，只使用我们上传的数据库。

1. **安装 Navidrome：** 在 VPS 上安装 Navidrome（例如使用 Docker）。
2. **配置 Navidrome：** 创建或修改 Navidrome 的配置文件 (`navidrome.toml`)，确保以下设置生效，以禁用扫描相关功能：

    ```toml
    # 指定数据目录，确保 navidrome.db 文件在此目录下
    DataFolder = "/path/to/your/navidrome/data" 
    # MusicFolder 理论上可以随意指定一个空目录，因为扫描已禁用
    MusicFolder = "/path/to/dummy/music/folder" 

    # 禁用内置的指标收集（可选）
    EnableInsightsCollector = false 
    # 设置默认语言（可选）
    DefaultLanguage = 'zh-Hans' 
    
    # --- 关键配置：禁用扫描 ---
    # 完全禁用扫描器
    Scanner.Enabled = false 
    # 禁用文件监控等待（无需监控本地文件变化）
    Scanner.WatcherWait = 0 
    # 禁用启动时扫描
    Scanner.ScanOnStartup = false 
    ```

3. **启动 Navidrome：** 启动 VPS 上的 Navidrome 服务。它现在应该能加载 `navidrome.db` 中的数据并提供 Web UI 和 API 服务，但不会尝试访问或验证音乐文件是否存在于 VPS 本地。

### 第三步：暴露 Navidrome 服务并使用 Cloudflare 代理 (可选但推荐)

你需要一种方式从公网访问部署在 VPS 上的 Navidrome 服务。

* **推荐方式：Cloudflare Tunnel:** 创建一个 Cloudflare Tunnel，将 VPS 上的 Navidrome 服务端口安全地暴露到公网，并绑定到你的域名 (例如 `navidrome.yourdomain.com`)。这是最安全且无需在 VPS 防火墙上开放端口的方式。
* **传统方式：** 如果你的 VPS 有公网 IP，可以在防火墙上开放 Navidrome 端口，然后在 Cloudflare DNS 中将你的域名指向该 VPS IP。

**无论哪种方式，确保你可以通过域名访问 Navidrome 的 Web 界面。**

### 第四步：创建文件 ID 到云端路径的映射数据库 (Cloudflare D1)

这一步是整个方案的核心：建立 Navidrome 内部文件 ID 与云存储中实际文件路径的对应关系。

1. **复制并编辑数据库：** 在你的本地计算机上，复制一份 `navidrome.db` 文件（避免直接修改原始文件）。使用 SQLite 编辑工具打开这份副本。
2. **提取关键数据：** 找到 `media_file` 表。删除除 `id` 和 `path` 之外的所有列。
    * **重要：** `path` 列存储的是 Navidrome 扫描时相对于 `MusicFolder` 的路径。**你需要确保这个路径与你的音乐文件在云存储中的相对路径完全一致。** 如果不一致，你可能需要批量修改 `path` 列的值，使其匹配云端结构。例如，如果本地路径是 `Music/Artist/Album/Song.mp3`，而云端存储桶内路径是 `Artist/Album/Song.mp3`，你需要去除 `Music/` 前缀。
3. **导出为 SQL：** 将修改后的 `media_file` 表导出为 SQL 文件，例如 `media_file.sql`。选择只导出数据 (INSERT 语句)。
4. **清理 SQL 文件：** 打开 `media_file.sql` 文件，删除文件开头可能存在的 `BEGIN TRANSACTION;` 或类似语句，以及文件末尾的 `COMMIT;` 或类似语句。确保文件内容主要是 `INSERT INTO media_file (id, path) VALUES (...);` 语句。
5. **创建 D1 数据库：** 使用 `wrangler` 或 Cloudflare 控制台创建一个 D1 数据库，例如命名为 `navidrome-db`。
6. **导入数据到 D1：** 使用 `wrangler` 将 SQL 文件中的数据导入 D1 数据库。执行以下命令（确保已登录 `wrangler`）：

    ```bash
    # 替换 'navidrome-db' 为你的 D1 数据库名称
    # --remote 表示操作线上的 D1 数据库
    npx wrangler d1 execute navidrome-db --remote --file=media_file.sql 
    ```

### 第五步：创建 Cloudflare Worker 拦截并重定向音乐流

现在，我们创建一个 Worker 脚本，它将拦截发往 Navidrome `/rest/stream` 端点的请求，并根据 D1 数据库中的映射关系重定向到云存储。

1. **创建 Worker：** 使用 `wrangler` 或 Cloudflare 控制台创建一个新的 Worker 服务。
2. **绑定 D1 数据库：** 在 Worker 的设置中，添加 D1 数据库绑定。将上一步创建的 D1 数据库 (`navidrome-db`) 绑定到 Worker，并设置绑定名称为 `DB`（代码中将通过 `env.DB` 访问）。
3. **编写 Worker 代码：** 编辑 Worker 的 `index.js` (或 `src/index.js`) 文件，粘贴以下代码：

    ```javascript
    // 重要：将 'https://your-cloud-storage-base-url/' 替换为你的云存储访问基地址
    // 例如 R2 公开访问 URL: 'https://<bucket>.<accountid>.r2.cloudflarestorage.com/'
    // 或 Alist 指向音乐根目录的 URL: 'https://your-alist.domain.com/dav/Music/' (确保路径结尾有斜杠)
    const BASE_URL = "https://your-cloud-storage-base-url/"; 

    export default {
      async fetch(request, env, ctx) {
        const url = new URL(request.url);
        const { pathname } = url;

        // 只处理 Navidrome 的音乐流请求
        if (pathname === "/rest/stream") {
          // 获取 Navidrome 传递的文件 ID
          const file_id = url.searchParams.get("id");
          if (!file_id) {
            return new Response("Missing 'id' parameter", { status: 400 });
          }

          try {
            // 在 D1 数据库中查询对应的路径
            // 'DB' 是你在 Worker 设置中配置的 D1 绑定名称
            const stmt = env.DB.prepare("SELECT path FROM media_file WHERE id = ?");
            const { results } = await stmt.bind(file_id).all();

            if (!results || results.length === 0) {
              console.error(`File ID not found in D1: ${file_id}`);
              return new Response("File mapping not found in D1", { status: 404 });
            }

            // 提取文件相对路径
            const filePath = results[0].path;

            // 对路径进行 URL 编码，防止特殊字符问题
            const encodedFilePath = encodeURIComponent(filePath).replace(/%2F/g, "/"); // 编码但保留斜杠

            // 构建完整的云存储文件 URL
            // 注意：确保 BASE_URL 结尾有斜杠，或者根据需要调整拼接逻辑
            const fileURL = BASE_URL + encodedFilePath;

            console.log(`Redirecting request for ID ${file_id} to: ${fileURL}`);

            // 返回 302 Found 重定向（或 301 Moved Permanently，根据需求选择）
            // 302 通常更适合动态内容，避免客户端永久缓存重定向
            return Response.redirect(fileURL, 302); 

          } catch (error) {
            console.error(`Error processing stream request for ID ${file_id}: ${error}`);
            return new Response("Internal server error", { status: 500 });
          }
        }

        // 对于非 /rest/stream 的请求，可以返回一个简单的响应或进行其他处理
        // 这里返回一个简单的 "Hello"，但在实际场景中，
        // 你可能需要将其他 Navidrome API 请求代理回源站（VPS上的Navidrome）
        // 这需要更复杂的 Worker 路由或 Cloudflare Spectrum 配置，超出了本教程范围
        // 简单的做法是：只让这个 Worker 处理 /rest/stream 路径
        // return fetch(request); // 如果 Worker 部署在 Navidrome 的主域名下，可能需要这样代理回源
        return new Response("Request not handled by this worker path", { status: 404 });
      },
    };
    ```

!!! warning
此次没有处理验证相关内容，如果注重安全还应代理验证请求，并记录token用于此处验证
!!!

4. **配置 Worker 路由：** 在 Cloudflare 控制台为你的 Worker 添加一个路由。
    * **路由模式：** `your.navidrome.domain.com/rest/stream*` （将 `your.navidrome.domain.com` 替换为你的 Navidrome 访问域名）
    * **服务：** 选择你刚刚创建的 Worker 服务。

    这样配置后，所有访问 Navidrome 音乐流端点的请求都会被这个 Worker 拦截处理。

### 第六步：处理专辑封面等静态资源 (TODO / 未来方向)

当前的 Worker 只处理了音乐文件 (`/rest/stream`) 的重定向。Navidrome 客户端（Web UI 或 App）还会请求专辑封面 (`/rest/getCoverArt`)、艺术家图片 (`/rest/getAvatar`) 等。

* **简单方案（可能有效）：** 如果你的专辑封面图片文件（如 `cover.jpg`）与音乐文件存储在云存储的同一目录下，并且 Navidrome 的数据库 (`media_file` 表中的信息或推断逻辑）能让客户端直接请求到正确的云端路径，那么可能无需额外处理。但这取决于 Navidrome 内部实现和你的文件结构。
* **更可靠方案：**
    1. **分析请求：** 查看浏览器开发者工具或 Navidrome App 的网络请求，确定获取封面的确切 API 端点和参数 (通常也包含一个 ID，可能是 `media_file` 的 `id` 或 `album` 的 `id`)。
    2. **扩展 D1 映射（如果需要）：** 如果封面路径不能简单从 `media_file` 推断，你可能需要从 `navidrome.db` 的其他表（如 `album`）提取信息，创建新的 D1 表或扩展现有表来映射封面 ID 到其云端路径。
    3. **扩展 Worker：** 修改 Worker 代码，增加对 `/rest/getCoverArt` 等路径的处理逻辑，查询 D1 获取封面路径，并重定向到云存储中的封面文件。
    4. **更新 Worker 路由：** 确保 Worker 路由也包含这些新的路径模式 (e.g., `your.navidrome.domain.com/rest/getCoverArt*`)。

这个步骤相对复杂，可以作为后续优化的方向。

### 总结

通过以上步骤，你就成功搭建了一个“混合模式”的 Navidrome 服务：元数据和 Web 服务运行在低存储的 VPS 上，而实际的音乐文件流则由 Cloudflare Workers 智能地重定向到你的大容量云存储。这既解决了 VPS 存储不足的问题，又让你能随时随地享受自己的音乐收藏。

记得定期（例如添加新音乐后）重复第一步（本地扫描）和第四步（更新 D1 数据库），以保持音乐库的同步。
